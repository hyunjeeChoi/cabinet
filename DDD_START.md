Chapter1. 도메인 모델 시작
============

## 밑줄 친 부분
 - 도메인 모델은 특정 도메인을 개념적으로 표현한 것
 - 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다.
 - 개념모델과 구현모델은 서로 다른 것이지만 구현 모델이 개념 모델을 최대한 따르도록 할 수 있다.
 - 도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴
 - 도메인 계층은 도메인의 핵심 규칙을 구현한다.
 - 핵심규칙을 구현한 코드는 구도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.
 - 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
 - 엔티티의 가장 큰 특징은 식별자를 갖는다는 것이다.
 - 식별자 생성 방식
   - 특정 규칙에 따라 생성
   - uuid 사용
   - 값을 직접 입력
   - 일련번호 사용 
 - 밸류 객체의 데이터를 변경할 떄는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호한다.
 - 도메인 모델에 set 넣지 않기
  - set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
  - 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다.
 - set메서드를 구현해야 할 특별한 이유가 없다면 불변 타입의 장점을 살릴 수 있도록 밸류 타입을 불변으로 구현한다.
 - 도메인 용어는 읽히기 쉽도록, 명료하게 쓴다.
      
      
## 느낀점
```
 - 습관적으로 사용하던 set메서드는 지양하고 set을 하는 경우에는 기능에 맞게 정확하게 구현하도록 해야 코드가독성이 높다.
 - 설계를 할 때는 중점이 될 수 있는 entity 를 먼저 뽑아내고 해당 엔티티들의 연관도, 안에서 구현될 내용을 생각한 뒤에 점점 결합시키는 것이 좋겠다.
```
 
Chapter2. 아키텍처 개요
==========

## 밑줄 친 부분
 - 표현 영역과 응용 영역은 도메인 영역을 사용하고 도메인 영역은 인프라스트럭처 영역을 사용ㅇ하므로 계층 구조를 적용하기에 적당해 보인다.
 - 계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.
 - 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 아래 계층인 인프라스트럭처 계층에 의존하기도 한다.
 - 인프라스트럭처에 의존하면 '테스트 어려움' 과 '기능 확장의 어려움; 이라는 문제가 발생하고 이 문제를 해소하는 방법은 DIP를 적용하는 것이다.
 - dip는 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 추상화한 인터페이스다.
 - 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 dependency inversion principle 의존 역전 원칙이라고 부른다.
 - dip를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있다. dip의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데 dip를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.
 - 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다. 
 - db테이블의 엔티티와 도메인 모델의 엔티티의 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다는 점이다. 예를 들어 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다. 
 - 도메인 모델의 엔티티는 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
 - 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸ㄹ류 타입을 이용해서 표현할 수 있다는 것이다. 
 - 애그리거트는 관련 객체를 하나로 묶은 군집이다.
 - 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고 트랜잭션 범위가 달라지기도 한다. 또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다. 
 - 구현의 편리함은 dip가 주는 다른 장점(변경의 유연함, 테스트가 쉬움)만큼 중요하기 때문에 dip의 장점을 해치지 않는 범위에서 응용영역과 도메인 영역에서의 구현 기술에 대한 의존을 가져가는 것이 현명하다.
 - 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다.
 
## 느낀점
```
 - 습관적으로 사용하는 스프링 어노테이션이 인프라스트럭처 영역과의 연관도라는 생각을 못하고 있었는데 이제 보니 연관을 지어서 쓰는거였구나 싶다.
 - 얼마나 dip가 잘되어져있느냐에 따라서 새로운 변경사항이 나타났을때 오류가 줄어들고 실제 필요한 테스트만 진행할 수 있겠다.
 - 인터페이스와 구현 클래스를 분리하는 정도인지 의존성을 없애고 모듈의 의존 관계를 역전시킨 것인지 코드를 보면서 깊게 봐야하겠다.
 - 도메인을 잘 나눠야 도메인별로의 기능 관리도 제대로 될 것으로 생각된다. 엔티티로 빠져야하는 부분이 혹여나 밸류로 들어가지 않도록 주의해서 봐야겠다.
``` 

Chapter3. 애그리거트
=================

- 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 된다. 모델을 보다 잘 이해할 수 있고 애그리거트 단위로 일관성을 관리하기 떄문에 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 노력도 줄어든다.
- 애그리거트는 독립된 객체군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.
- 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티로 애그리거트에 속한 객체는 애그리거트 루트 앤티티에 직접 또는 간접적으로 속한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
- 단순히 필드를 변경하는 set메서드는 공개 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실현을 위임하기도 한다.
- 보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 떄문에 패키지나 protected범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있따.
- 트랜잭션 범위는 작을수록 좋다.
- 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
- 애그리거트를 직접 참조할 때 생길 수 있는 문제점
  - 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.
  - 애그리거트를 직접 참조하면 성능과 관련된 여러 가지 고민을 해야 한다.
  - 확장이 어려워진다.
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.

### 느낀점
```
 - 내가 작성한 코드에도 트랜잭션을 상당히 크게 잡고 여러개의 애그리거트를 수정하게 하는 경우가 많다. 그럴 수 밖에 없어서였는지 구분할 수 있었는지 고민이 필요하다.
```

